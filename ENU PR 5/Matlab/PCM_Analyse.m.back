% PCM_Analyse.m
clear all;
%close all;
load('pcm_data_test.mat')
% A... Spannungssignal
% B... Bitwörter+Rahmensynchronisationssignal


%Filter Kanal B
B_filt=PerfectTP(B,1/Tinterval,200e3);
% Split gefilterten Kanal B
[Data Rahmen]=Split(B_filt);
% Data bereinigen:
Data(Data<2.5)=0;
Data(Data>=2.5)=1;



%Rahmen = [0 0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1]'


% die folgende routine würde das erste Bit ausgelassen wenn die Aufnahme der
% Messwerte bei einer fallenden Flanke startet

if Rahmen(1) == 1 && Rahmen(2) == 0
    display('Möööööööööp')
end

% Vektor erstellen, der eine 1 enthält wo ein neues Bit anfängt
WortStart = Rahmen(2:end) -Rahmen(1:end-1);

% entstadene negative Werte löschen
WortStart(WortStart<0) = 0;

% eine null am Anfang ist verloren gegangen
WortStart = [0; WortStart];


% 
BitProWort = 8;

% Anzahl Worte:
% das erste und das letzte Wort ist nicht volständig. das erste gucken wir
% uns eh nicht an, das letzte darf aber nicht mehr bearbeitet werden.
AnzahlBitWorte = sum(WortStart) -1;

% Vektor für die Dezimalwerte der Bitworte
DecVal=ones(1,AnzahlBitWorte)*7;
% Vektor für die zugehörigen Spannungspegel
VoltVal=ones(1,AnzahlBitWorte)*8;

for i=1:AnzahlBitWorte
    
        
    % index der ersten 1 finden
    [Y,anf] = max(WortStart);
    
    % führende nullen löschen (aus "end" macht Matlab "length(Daten)")
    WortStart = WortStart(anf:end);
    Data = Data(anf:end);
    anf = 1;
    
    % erste 1 löschen
    WortStart(anf) = 0;
    
    % end ist von matlab reserviert 
    [Y,ende]= max(WortStart);
    
    % ich will nicht die nächste 1 sondern die null vor der 1
    ende = ende-1;
   
    % Wie viele werte sind denn zwischen anf und ende
    TastWerte = ende-anf+1;
    
    % es wird 8 Bits geben in diesem Wort
    Bits = zeros(1,8);    
    
    j = 8;
    for l=1:8
        zuBearbeiten = round(TastWerte/j);
        Bits(l) = sum(  Data( anf:anf+round(TastWerte/j) )  )/round(TastWerte/j);
        anf = anf + round(TastWerte/j);
        TastWerte = TastWerte -round(TastWerte/j);
        j = j - 1;
    end
    
    Bits(Bits<0.5)=0;
    Bits(Bits>=0.5)=1;
    
    
    DecVal(i)  = bin2dec(num2str(Bits));      % Vervollständigen
    VoltVal(i) = (DecVal(i))*(4/255)-2;       % Vervollständigen
    
    % Verarbeitete Daten löschen
    WortStart = WortStart(ende+1:end);
    Data = Data(ende+1:end);
end
length(Data)

stem(VoltVal,DecVal)
xlabel('Volt')
ylabel('Abtaststufe')